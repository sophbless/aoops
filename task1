import random
from abc import ABC, abstractmethod

# Singleton Pattern: 
class GameData:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(GameData, cls).__new__(cls)
            cls._instance.current_level = 1
            cls._instance.difficulty_setting = "Easy"
        return cls._instance

    def update_level(self, level):
        self.current_level = level

    def update_difficulty(self, difficulty):
        self.difficulty_setting = difficulty

    def get_game_data(self):
        return {
            "current_level": self.current_level,
            "difficulty_setting": self.difficulty_setting
        }

# Factory Method Pattern:
class Enemy(ABC):
    @abstractmethod
    def attack(self):
        pass

class Orc(Enemy):
    def attack(self):
        return "Orc charges with a mace!"

class Wyvern(Enemy):
    def attack(self):
        return "Wyvern swoops down and strikes!"

class EnemyFactory:
    @staticmethod
    def get_enemy(level):
        if level < 3:
            return Orc()
        else:
            return Wyvern()

# Abstract Factory Pattern: 
class Weapon(ABC):
    @abstractmethod
    def use(self):
        pass

class PowerUp(ABC):
    @abstractmethod
    def activate(self):
        pass

class Axe(Weapon):
    def use(self):
        return "Swinging the axe!"

class Crossbow(Weapon):
    def use(self):
        return "Firing a bolt from the crossbow!"

class HealingPotion(PowerUp):
    def activate(self):
        return "Drinking the potion to heal!"

class EnergyShield(PowerUp):
    def activate(self):
        return "Using the energy shield!"

class ItemFactory(ABC):
    @abstractmethod
    def create_weapon(self):
        pass

    @abstractmethod
    def create_power_up(self):
        pass

class BeginnerItemFactory(ItemFactory):
    def create_weapon(self):
        return Axe()

    def create_power_up(self):
        return HealingPotion()

class AdvancedItemFactory(ItemFactory):
    def create_weapon(self):
        return Crossbow()

    def create_power_up(self):
        return EnergyShield()

# Game Application
class Game:
    def __init__(self):
        self.game_data = GameData()

    def play_level(self):
        level = self.game_data.current_level
        difficulty = self.game_data.difficulty_setting

        # Create enemy for the level
        enemy = EnemyFactory.get_enemy(level)
        print(f"Level {level} - Enemy Encountered: {enemy.attack()}")

        # Create items based on difficulty
        item_factory = BeginnerItemFactory() if difficulty == "Easy" else AdvancedItemFactory()
        weapon = item_factory.create_weapon()
        power_up = item_factory.create_power_up()

        print(f"Weapon: {weapon.use()}")
        print(f"Power-Up: {power_up.activate()}")

    def next_level(self):
        self.game_data.update_level(self.game_data.current_level + 1)
        if self.game_data.current_level > 3:
            self.game_data.update_difficulty("Hard")
        print(f"Moving to Level {self.game_data.current_level}, Difficulty: {self.game_data.difficulty_setting}")


if __name__ == "__main__":
    game = Game()

    for _ in range(5):
        game.play_level()
        game.next_level()
